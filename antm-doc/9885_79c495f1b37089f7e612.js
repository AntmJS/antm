"use strict";(self.webpackChunk_antmjs_doc=self.webpackChunk_antmjs_doc||[]).push([[9885],{9885:function(e,n,a){a.r(n),n.default={tile:"!/usr/bin/envnode",docs:"<p>#!/usr/bin/env node</p>\n<p>const fs = require('fs')\nconst path = require('path')\nconst pkg = require('../package.json')\nconst JSON5 = require('./')</p>\n<p>const argv = parseArgs()</p>\n<p>if (argv.version) {\nversion()\n} else if (argv.help) {\nusage()\n} else {\nconst inFilename = argv.defaults[0]</p>\n<pre><code>let readStream\nif (inFilename) {\n    readStream = fs.createReadStream(inFilename)\n} else {\n    readStream = process.stdin\n}\n\nlet json5 = ''\nreadStream.on('data', data =&gt; {\n    json5 += data\n})\n\nreadStream.on('end', () =&gt; {\n    let space\n    if (argv.space === 't' || argv.space === 'tab') {\n        space = '\t'\n    } else {\n        space = Number(argv.space)\n    }\n\n    let value\n    try {\n        value = JSON5.parse(json5)\n        if (!argv.validate) {\n            const json = JSON.stringify(value, null, space)\n\n            let writeStream\n\n            // --convert is for backward compatibility with v0.5.1. If\n            // specified with &lt;file&gt; and not --out-file, then a file with\n            // the same name but with a .json extension will be written.\n            if (argv.convert &amp;&amp; inFilename &amp;&amp; !argv.outFile) {\n                const parsedFilename = path.parse(inFilename)\n                const outFilename = path.format(\n                    Object.assign(\n                        parsedFilename,\n                        {base: path.basename(parsedFilename.base, parsedFilename.ext) + '.json'}\n                    )\n                )\n\n                writeStream = fs.createWriteStream(outFilename)\n            } else if (argv.outFile) {\n                writeStream = fs.createWriteStream(argv.outFile)\n            } else {\n                writeStream = process.stdout\n            }\n\n            writeStream.write(json)\n        }\n    } catch (err) {\n        console.error(err.message)\n        process.exit(1)\n    }\n})\n</code></pre>\n<p>}</p>\n<p>function parseArgs () {\nlet convert\nlet space\nlet validate\nlet outFile\nlet version\nlet help\nconst defaults = []</p>\n<pre><code>const args = process.argv.slice(2)\nfor (let i = 0; i &lt; args.length; i++) {\n    const arg = args[i]\n    switch (arg) {\n    case '--convert':\n    case '-c':\n        convert = true\n        break\n\n    case '--space':\n    case '-s':\n        space = args[++i]\n        break\n\n    case '--validate':\n    case '-v':\n        validate = true\n        break\n\n    case '--out-file':\n    case '-o':\n        outFile = args[++i]\n        break\n\n    case '--version':\n    case '-V':\n        version = true\n        break\n\n    case '--help':\n    case '-h':\n        help = true\n        break\n\n    default:\n        defaults.push(arg)\n        break\n    }\n}\n\nreturn {\n    convert,\n    space,\n    validate,\n    outFile,\n    version,\n    help,\n    defaults,\n}\n</code></pre>\n<p>}</p>\n<p>function version () {\nconsole.log(pkg.version)\n}</p>\n<p>function usage () {\nconsole.log(\n::::_QA\nUsage: json5 [options] <file></p>\n<p>If <file> is not provided, then STDIN is used.</p>\n<p>Options:</p>\n<pre><code>-s, --space              The number of spaces to indent or 't' for tabs\n-o, --out-file [file]    Output to the specified file, otherwise STDOUT\n-v, --validate           Validate JSON5 but do not output JSON\n-V, --version            Output the version number\n-h, --help               Output usage information::::_QA\n)\n</code></pre>\n<p>}</p>\n",h3Ids:"",codePath:[]}}}]);