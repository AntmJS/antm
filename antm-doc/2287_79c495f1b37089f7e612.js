"use strict";(self.webpackChunk_antmjs_doc=self.webpackChunk_antmjs_doc||[]).push([[2287],{2287:function(n,e,t){t.r(e),e.default={tile:"!/usr/bin/envnode",docs:"<p>#!/usr/bin/env node</p>\n<p>/**</p>\n<ul>\n<li>@fileoverview Main CLI that is run via the eslint command.</li>\n<li>@author Nicholas C. Zakas\n*/</li>\n</ul>\n<p>/* eslint no-console:off -- CLI */</p>\n<p>&quot;use strict&quot;;</p>\n<p>// to use V8's code cache to speed up instantiation time\nrequire(&quot;v8-compile-cache&quot;);</p>\n<p>// must do this initialization <em>before</em> other requires in order to work\nif (process.argv.includes(&quot;--debug&quot;)) {\nrequire(&quot;debug&quot;).enable(&quot;eslint:<em>,-eslint:code-path,eslintrc:</em>&quot;);\n}</p>\n<p>//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------</p>\n<p>/**</p>\n<ul>\n<li>\n<p>Read data from stdin til the end.</p>\n</li>\n<li></li>\n<li>\n<p>Note: See</p>\n</li>\n<li>\n<ul>\n<li>https://github.com/nodejs/node/blob/master/doc/api/process.md#processstdin</li>\n</ul>\n</li>\n<li>\n<ul>\n<li>https://github.com/nodejs/node/blob/master/doc/api/process.md#a-note-on-process-io</li>\n</ul>\n</li>\n<li>\n<ul>\n<li>https://lists.gnu.org/archive/html/bug-gnu-emacs/2016-01/msg00419.html</li>\n</ul>\n</li>\n<li>\n<ul>\n<li>https://github.com/nodejs/node/issues/7439 (historical)</li>\n</ul>\n</li>\n<li></li>\n<li>\n<p>On Windows using <code>fs.readFileSync(STDIN_FILE_DESCRIPTOR, &quot;utf8&quot;)</code> seems</p>\n</li>\n<li>\n<p>to read 4096 bytes before blocking and never drains to read further data.</p>\n</li>\n<li></li>\n<li>\n<p>The investigation on the Emacs thread indicates:</p>\n</li>\n<li></li>\n<li>\n<blockquote>\n<p>Emacs on MS-Windows uses pipes to communicate with subprocesses; a</p>\n</blockquote>\n</li>\n<li>\n<blockquote>\n<p>pipe on Windows has a 4K buffer. So as soon as Emacs writes more than</p>\n</blockquote>\n</li>\n<li>\n<blockquote>\n<p>4096 bytes to the pipe, the pipe becomes full, and Emacs then waits for</p>\n</blockquote>\n</li>\n<li>\n<blockquote>\n<p>the subprocess to read its end of the pipe, at which time Emacs will</p>\n</blockquote>\n</li>\n<li>\n<blockquote>\n<p>write the rest of the stuff.</p>\n</blockquote>\n</li>\n<li>\n<p>@returns {Promise<string>} The read text.\n*/\nfunction readStdin() {\nreturn new Promise((resolve, reject) =&gt; {\nlet content = &quot;&quot;;\nlet chunk = &quot;&quot;;</p>\n<pre><code> process.stdin\n     .setEncoding(&quot;utf8&quot;)\n     .on(&quot;readable&quot;, () =&gt; {\n         while ((chunk = process.stdin.read()) !== null) {\n             content += chunk;\n         }\n     })\n     .on(&quot;end&quot;, () =&gt; resolve(content))\n     .on(&quot;error&quot;, reject);\n</code></pre>\n<p>});\n}</p>\n</li>\n</ul>\n<p>/**</p>\n<ul>\n<li>\n<p>Get the error message of a given value.</p>\n</li>\n<li>\n<p>@param {any} error The value to get.</p>\n</li>\n<li>\n<p>@returns {string} The error message.\n*/\nfunction getErrorMessage(error) {</p>\n<p>// Lazy loading because this is used only if an error happened.\nconst util = require(&quot;util&quot;);</p>\n<p>// Foolproof -- third-party module might throw non-object.\nif (typeof error !== &quot;object&quot; || error === null) {\nreturn String(error);\n}</p>\n<p>// Use templates if <code>error.messageTemplate</code> is present.\nif (typeof error.messageTemplate === &quot;string&quot;) {\ntry {\nconst template = require(<code>../messages/::::_ABerror.messageTemplate}.js</code>);</p>\n<pre><code>     return template(error.messageData || {});\n } catch {\n\n     // Ignore template error then fallback to use ::::_QAerror.stack::::_QA.\n }\n</code></pre>\n<p>}</p>\n<p>// Use the stacktrace if it's an error object.\nif (typeof error.stack === &quot;string&quot;) {\nreturn error.stack;\n}</p>\n<p>// Otherwise, dump the object.\nreturn util.format(&quot;%o&quot;, error);\n}</p>\n</li>\n</ul>\n<p>/**</p>\n<ul>\n<li>\n<p>Catch and report unexpected error.</p>\n</li>\n<li>\n<p>@param {any} error The thrown error object.</p>\n</li>\n<li>\n<p>@returns {void}\n*/\nfunction onFatalError(error) {\nprocess.exitCode = 2;</p>\n<p>const { version } = require(&quot;../package.json&quot;);\nconst message = getErrorMessage(error);</p>\n<p>console.error(::::_QA\nOops! Something went wrong! :(</p>\n</li>\n</ul>\n<p>ESLint: ::::_ABversion}</p>\n<p>::::_ABmessage}::::_QA);\n}</p>\n<p>//------------------------------------------------------------------------------\n// Execution\n//------------------------------------------------------------------------------</p>\n<p>(async function main() {\nprocess.on(&quot;uncaughtException&quot;, onFatalError);\nprocess.on(&quot;unhandledRejection&quot;, onFatalError);</p>\n<pre><code>// Call the config initializer if ::::_QA--init::::_QA is present.\nif (process.argv.includes(&quot;--init&quot;)) {\n\n    // ::::_QAeslint --init::::_QA has been moved to ::::_QA@eslint/create-config::::_QA\n    console.warn(&quot;You can also run this command directly using 'npm init @eslint/config'.&quot;);\n\n    const spawn = require(&quot;cross-spawn&quot;);\n\n    spawn.sync(&quot;npm&quot;, [&quot;init&quot;, &quot;@eslint/config&quot;], { encoding: &quot;utf8&quot;, stdio: &quot;inherit&quot; });\n    return;\n}\n\n// Otherwise, call the CLI.\nprocess.exitCode = await require(&quot;../lib/cli&quot;).execute(\n    process.argv,\n    process.argv.includes(&quot;--stdin&quot;) ? await readStdin() : null\n);\n</code></pre>\n<p>}()).catch(onFatalError);</p>\n",h3Ids:"",codePath:[]}}}]);